/**============================================================
 * 版权： 久其软件 版权所有 (c) 2002 - 2016
 * 包： com.adaivskenan.gof.factory
 * 修改记录：
 * 日期                作者           内容
 * =============================================================
 * 2018年1月31日       qinjunjie        
 * ============================================================*/

/**
 * <p> FACTORY METHORD工厂方法模式</p>
 * 核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，
 * 成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触
 * 哪一个产品类应当被实例化这种细节。
 *
 * <p>Copyright: 版权所有 (c) 2002 - 2016<br>
 * Company: 久其</p>
 *
 * @author qinjunjie
 * @version 2018年1月31日
 */

package com.adaivskenan.gof.factory;

/**
 * 
 * 工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类
 * 实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，
 * 又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic 
 * Factory Pattern)。工厂方法模式是一种类创建型模式。
 * 
 *	● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的
 *公共父类。
 *	● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建
 *，具体工厂和具体产品之间一一对应。
 *	● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。
 *抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
 *	● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由
 *客户端调用，返回一个具体产品类的实例。
 *
 * 在以下情况下可以考虑使用工厂方法模式：
 * 	(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所
 * 对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。
 * 	(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的
 * 接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖
 * 父类对象，从而使得系统更容易扩展。
 * */
